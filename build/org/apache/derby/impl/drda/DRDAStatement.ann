 47119        djd /*
 47119        djd 
 57533        djd    Derby - Class org.apache.derby.impl.drda.DRDAStatement
 47119        djd 
429803 fuzzylogic    Licensed to the Apache Software Foundation (ASF) under one or more
429803 fuzzylogic    contributor license agreements.  See the NOTICE file distributed with
429803 fuzzylogic    this work for additional information regarding copyright ownership.
429803 fuzzylogic    The ASF licenses this file to You under the Apache License, Version 2.0
429803 fuzzylogic    (the "License"); you may not use this file except in compliance with
429803 fuzzylogic    the License.  You may obtain a copy of the License at
 57533        djd 
 57533        djd       http://www.apache.org/licenses/LICENSE-2.0
 57533        djd 
 57533        djd    Unless required by applicable law or agreed to in writing, software
 57533        djd    distributed under the License is distributed on an "AS IS" BASIS,
 57533        djd    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 57533        djd    See the License for the specific language governing permissions and
 57533        djd    limitations under the License.
 57533        djd 
 47119        djd  */
 47119        djd 
 47119        djd package org.apache.derby.impl.drda;
 47119        djd 
581031   kmarsden import java.io.IOException;
189752   kmarsden import java.io.UnsupportedEncodingException;
189752   kmarsden import java.lang.reflect.InvocationTargetException;
189752   kmarsden import java.lang.reflect.Method;
189752   kmarsden import java.math.BigInteger;
189752   kmarsden import java.sql.CallableStatement;
 47119        djd import java.sql.Connection;
495543   kahatlen import java.sql.ParameterMetaData;
 47119        djd import java.sql.PreparedStatement;
 47119        djd import java.sql.ResultSet;
 47119        djd import java.sql.SQLException;
189752   kmarsden import java.sql.Statement;
 47119        djd import java.util.ArrayList;
189752   kmarsden import java.util.Hashtable;
 47119        djd import java.util.StringTokenizer;
 47119        djd import java.util.Vector;
467612   kahatlen import java.lang.reflect.Array;
 47119        djd 
189752   kmarsden import org.apache.derby.iapi.jdbc.BrokeredConnection;
189752   kmarsden import org.apache.derby.iapi.jdbc.BrokeredPreparedStatement;
380278        djd import org.apache.derby.iapi.jdbc.EngineConnection;
421435    davidvc import org.apache.derby.iapi.jdbc.EnginePreparedStatement;
 47119        djd import org.apache.derby.iapi.reference.JDBC30Translation;
 47119        djd import org.apache.derby.iapi.sql.execute.ExecutionContext;
 47119        djd import org.apache.derby.iapi.util.StringUtil;
189752   kmarsden import org.apache.derby.impl.jdbc.Util;
 47119        djd 
 47119        djd /**
 47119        djd 	DRDAStatement stores information about the statement being executed
 47119        djd */
 47119        djd class DRDAStatement
 47119        djd {
 47119        djd 
381937   kmarsden 	//NOTE!
381937   kmarsden 	//
381937   kmarsden 	// Since DRDAStatements are reused, ALL variables (except those noted in 
381937   kmarsden 	// the comments for reset method) should be set to their default values 
381937   kmarsden 	// in reset().
381937   kmarsden 	
 47119        djd 
 47119        djd 	protected String typDefNam;		//TYPDEFNAM for this statement
 47119        djd 	protected int byteOrder;		//deduced from typDefNam, save String comparisons
 47119        djd 	protected int ccsidSBC;			//CCSID for single byte characters
 47119        djd 	protected int ccsidDBC;			//CCSID for double byte characters
 47119        djd 	protected int ccsidMBC;			//CCSID for mixed byte characters
 47119        djd 	protected String ccsidSBCEncoding;	//Java encoding for CCSIDSBC
 47119        djd 	protected String ccsidDBCEncoding;	//Java encoding for CCSIDDBC
 47119        djd 	protected String ccsidMBCEncoding;	//Java encoding for CCSIDMBC
 47119        djd 
 47119        djd 	protected Database database;		// Database this statement is created for
368333      bernt 	private   Pkgnamcsn pkgnamcsn;		// Package name/section # and  consistency token
368333      bernt 	protected ConsistencyToken pkgcnstkn;       // Consistency token for the first result set
 47119        djd  	protected String pkgid;              // package id
368333      bernt  	protected int pkgsn;		// section number
380278        djd 	int withHoldCursor = -1;	 // hold cursor after commit attribute.
 47119        djd 	protected int isolationLevel;         //JCC isolation level for Statement
 47119        djd 	protected String cursorName;
123827   kmarsden 	protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;			// Sensitive or Insensitive scroll attribute
123827   kmarsden 	protected int concurType = ResultSet.CONCUR_READ_ONLY;;			// Concurency type
 47119        djd 	protected long rowCount;			// Number of rows we have processed
 47119        djd 	protected byte [] rslsetflg;		// Result Set Flags
 47119        djd 	protected int maxrslcnt;			// Maximum Result set count
 47119        djd 	protected PreparedStatement ps;     // Prepared statement
495543   kahatlen 	protected ParameterMetaData stmtPmeta; // param metadata
 47119        djd 	protected boolean isCall;
 47119        djd 	protected String procName;			// callable statement's method name
 47119        djd 	private   int[] outputTypes;		// jdbc type for output parameter or NOT_OUTPUT_PARAM
 47119        djd 	                                    // if not an output parameter.
534985   kmarsden 	private int[] outputPrecision;
534985   kmarsden 	private int[] outputScale;
534985   kmarsden         
 47119        djd 	protected static int NOT_OUTPUT_PARAM = -100000;
 47119        djd 	protected boolean outputExpected;	// expect output from a callable statement
 47119        djd 	private Statement stmt;				// SQL statement
 47119        djd 
 47119        djd 
 47119        djd 	private DRDAResultSet currentDrdaRs;  // Current ResultSet
 47119        djd 	private Hashtable resultSetTable;     // Hashtable with resultsets            
 47119        djd 	private ArrayList resultSetKeyList;  // ordered list of hash keys
 47119        djd 	private int numResultSets = 0;  
 47119        djd 
467612   kahatlen 	/** This class is used to keep track of the statement's parameters
467612   kahatlen 	 * as they are received from the client. It uses arrays to track
467612   kahatlen 	 * the DRDA type, the length in bytes and the externalness of each
467612   kahatlen 	 * parameter. Arrays of int/byte are used rather than ArrayLists
467612   kahatlen 	 * of Integer/Byte in order to re-use the same storage each time
467612   kahatlen 	 * the statement is executed. */
467612   kahatlen 	private static class DrdaParamState {
581031   kmarsden 		// The last parameter may be streamed. 
581031   kmarsden 		// We need to keep a record of it so we can drain it if it is not 
581031   kmarsden 		// used.
581031   kmarsden 		// Only the last parameter with an EXTDTA will be streamed. 
581031   kmarsden 		//(See DRDAConnThread.readAndSetAllExtParams()). 
581031   kmarsden 		private EXTDTAReaderInputStream streamedParameter = null;
467612   kahatlen 		private int typeLstEnd_ = 0;
467612   kahatlen 		private byte[] typeLst_ = new byte[10];
467612   kahatlen 		private int[]  lenLst_ = new int[10];
467612   kahatlen 		private int extLstEnd_ = 0;
467612   kahatlen 		private int[]  extLst_ = new int[10];
 47119        djd 
467612   kahatlen 		private static Object growArray(Object array) {
467612   kahatlen 			final int oldLen = Array.getLength(array);
467612   kahatlen 			Object tmp =
467612   kahatlen 				Array.newInstance(array.getClass().getComponentType(),
467612   kahatlen 								  Math.max(oldLen,1)*2);
467612   kahatlen 			System.arraycopy(array, 0, tmp, 0, oldLen);
467612   kahatlen 			return tmp;
467612   kahatlen 		}
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>clear</code> resets the arrays so that new parameters
467612   kahatlen 		 * will be added at the beginning. No initialization or
467612   kahatlen 		 * releasing of storage takes place unless the trim argument
467612   kahatlen 		 * is true.
467612   kahatlen 		 *
467612   kahatlen 		 * @param trim - if true; release excess storage
467612   kahatlen 		 */
467612   kahatlen 		protected void clear(boolean trim) {
581031   kmarsden 			streamedParameter = null;
467612   kahatlen 			typeLstEnd_ = 0;
467612   kahatlen 			extLstEnd_ = 0;
467612   kahatlen 			if (trim && typeLst_.length > 10) {
467612   kahatlen 				typeLst_ = new byte[10];
467612   kahatlen 				lenLst_ = new int[10];
467612   kahatlen 				extLst_ = new int[10];
467612   kahatlen 			}
467612   kahatlen 		}
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>addDrdaParam</code> adds a new parameter with its
467612   kahatlen 		 * DRDA type and byte length. The arrays are automatically
467612   kahatlen 		 * grown if needed.
467612   kahatlen 		 *
467612   kahatlen 		 * @param t a <code>byte</code> value, the DRDA type of the
467612   kahatlen 		 * parameter being added
467612   kahatlen 		 * @param s an <code>int</code> value, the length in bytes of
467612   kahatlen 		 * the parameter being added
467612   kahatlen 		 */
467612   kahatlen 		protected void addDrdaParam(byte t, int s) {
467612   kahatlen 			if (typeLstEnd_ >= typeLst_.length) {
467612   kahatlen 				typeLst_ = (byte[])growArray(typeLst_);
467612   kahatlen 				lenLst_ = (int[])growArray(lenLst_);
467612   kahatlen 			}
467612   kahatlen 			typeLst_[typeLstEnd_] = t;
467612   kahatlen 			lenLst_[typeLstEnd_] = s;
467612   kahatlen 			++typeLstEnd_;
467612   kahatlen 		}
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>getDrdaParamCount</code> return the number of
467612   kahatlen 		 * parameters added so far (since last clear).
467612   kahatlen 		 *
467612   kahatlen 		 * @return an <code>int</code> value, the number of parameters
467612   kahatlen 		 */
467612   kahatlen 		protected int  getDrdaParamCount() { return typeLstEnd_; }
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>getDrdaType</code> returns a byte that represents the
467612   kahatlen 		 * DRDA type of the ith parameter.
467612   kahatlen 		 *
467612   kahatlen 		 * @param i an <code>int</code> value, a parameter position
467612   kahatlen 		 * (zero-based)
467612   kahatlen 		 * @return a <code>byte</code> value, the DRDA type
467612   kahatlen 		 */
467612   kahatlen 		protected byte getDrdaType(int i) { return typeLst_[i]; }
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>getDrdaLen</code> returns the length in bytes of the
467612   kahatlen 		 * ith parameter.
467612   kahatlen 		 *
467612   kahatlen 		 * @param i an <code>int</code> value, a parameter position
467612   kahatlen 		 * (zero-based)
467612   kahatlen 		 * @return an <code>int</code> value
467612   kahatlen 		 */
467612   kahatlen 		protected int getDrdaLen(int i) { return lenLst_[i]; }
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>addExtPos</code> marks parameter i as external. The
467612   kahatlen 		 * array is grown as needed.
467612   kahatlen 		 *
467612   kahatlen 		 * @param p an <code>int</code> value, a parameter position
467612   kahatlen 		 * (zero-based)
467612   kahatlen 		 */
467612   kahatlen 		protected void addExtPos(int p) {
467612   kahatlen 			if (extLstEnd_ >= extLst_.length) {
467612   kahatlen 				extLst_ = (int[])growArray(extLst_);
467612   kahatlen 			}
467612   kahatlen 			extLst_[extLstEnd_] = p;
467612   kahatlen 			++extLstEnd_;
467612   kahatlen 		}
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>getExtPosCount</code> returns the number of
467612   kahatlen 		 * parameters marked as external so far (since last clear).
467612   kahatlen 		 *
467612   kahatlen 		 * @return an <code>int</code> value, the number of external
467612   kahatlen 		 * parameters.
467612   kahatlen 		 */
467612   kahatlen 		protected int getExtPosCount() { return extLstEnd_; }
467612   kahatlen 
467612   kahatlen 		/**
467612   kahatlen 		 * <code>getExtPos</code> returns the actual parameter position
467612   kahatlen 		 * of the ith external parameter.
467612   kahatlen 		 *
467612   kahatlen 		 * @param i an <code>int</code> value, index into the list of
467612   kahatlen 		 * external parameters, zero-based
467612   kahatlen 		 * @return an <code>int</code> value, the parameter position
467612   kahatlen 		 * of the ith external parameter (zero-based)
467612   kahatlen 		 */
467612   kahatlen 		protected int getExtPos(int i) { return extLst_[i]; }
581031   kmarsden         
581031   kmarsden 		/**
581031   kmarsden 		 * Read the rest of the streamed parameter if not consumed
581031   kmarsden 		 * by the executing statement.  DERBY-3085
581031   kmarsden 		 * @throws IOException
581031   kmarsden 		 */
581031   kmarsden 		protected void drainStreamedParameter() throws IOException
581031   kmarsden 		{
581031   kmarsden 			if (streamedParameter != null)
581031   kmarsden 			{   
581031   kmarsden 				// we drain the buffer 1000 bytes at a time.
581031   kmarsden 				// 1000 is just a random selection that doesn't take
581031   kmarsden 				// too much memory. Perhaps something else would be 
581031   kmarsden 				// more efficient?
581031   kmarsden 				byte[] buffer = new byte[1000];
581031   kmarsden 				int i;
581031   kmarsden 				do {
581031   kmarsden 					i= streamedParameter.read(buffer,0,1000);
581031   kmarsden 				}  while (i != -1);
581031   kmarsden 			}
581031   kmarsden 		}
581031   kmarsden             
581031   kmarsden 
581031   kmarsden 		public void setStreamedParameter(EXTDTAReaderInputStream eis) {
581031   kmarsden 			streamedParameter = eis;    
581031   kmarsden 		}
581031   kmarsden 		
467612   kahatlen 	}
467612   kahatlen 	private DrdaParamState drdaParamState_ = new DrdaParamState();
467612   kahatlen 
 47119        djd 	// Query options  sent on EXCSQLSTT
 47119        djd 	// These the default for ResultSets created for this statement.
 47119        djd 	// These can be overriden by OPNQRY or CNTQRY,
 47119        djd 	protected int nbrrow;			// number of fetch or insert rows
 47119        djd 	protected int qryrowset;			// Query row set
 47119        djd 	protected int blksize;				// Query block size
 47119        djd 	protected int maxblkext;			// Maximum number of extra blocks
 47119        djd 	protected int outovropt;			// Output Override option
 47119        djd 	protected boolean qryrfrtbl;		// Query refresh answer set table
 47119        djd 	private int qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;   // Protocol type
 47119        djd 	
 47119        djd 	
 47119        djd 
 47119        djd 	boolean needsToSendParamData = false;
 47119        djd 	boolean explicitlyPrepared = false;    //Prepared with PRPSQLSTT (reusable) 
 47119        djd 
 47119        djd 	// constructor
 47119        djd 	/**
 47119        djd 	 * DRDAStatement constructor
 47119        djd 	 *
 47119        djd 	 * @param database
 47119        djd 	 * 
 47119        djd 	 */
379174        djd 	DRDAStatement (Database database) 
 47119        djd 	{
 47119        djd 		this.database = database;
 47119        djd 		setTypDefValues();
 47119        djd 		this.currentDrdaRs = new DRDAResultSet();
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * set TypDef values
 47119        djd 	 *
 47119        djd 	 */
 47119        djd 	protected void setTypDefValues()
 47119        djd 	{
 47119        djd 		// initialize statement values to current database values
 47119        djd 		this.typDefNam = database.typDefNam;
 47119        djd 		this.byteOrder = database.byteOrder;
 47119        djd 		this.ccsidSBC = database.ccsidSBC;
 47119        djd 		this.ccsidDBC = database.ccsidDBC;
 47119        djd 		this.ccsidMBC = database.ccsidMBC;
 47119        djd 		this.ccsidSBCEncoding = database.ccsidSBCEncoding;
 47119        djd 		this.ccsidDBCEncoding = database.ccsidDBCEncoding;
 47119        djd 		this.ccsidMBCEncoding = database.ccsidMBCEncoding;
 47119        djd 	}
 47119        djd 	/**
 47119        djd 	 * Set database
 47119        djd 	 *
 47119        djd 	 * @param database
 47119        djd 	 */
 47119        djd 	protected void setDatabase(Database database)
 47119        djd 	{
 47119        djd 		this.database = database;
 47119        djd 		setTypDefValues();
 47119        djd 	}
 47119        djd 	/**
 47119        djd 	 * Set statement
 47119        djd 	 *
 47119        djd 	 * @param conn	Connection
 47119        djd 	 * @exception SQLException
 47119        djd 	 */
 47119        djd 	protected void setStatement(Connection conn)
 47119        djd 		throws SQLException
 47119        djd 	{
 47119        djd 		stmt = conn.createStatement();
 47119        djd 		//beetle 3849 -  see  prepareStatement for details
 47119        djd 		if (cursorName != null)
 47119        djd 			stmt.setCursorName(cursorName);
 47119        djd 	}
 47119        djd 	/**
 47119        djd 	 * Get the statement
 47119        djd 	 *
 47119        djd 	 * @return statement
 47119        djd 	 * @exception SQLException
 47119        djd 	 */
 47119        djd 	protected Statement getStatement() 
 47119        djd 		throws SQLException
 47119        djd 	{
 47119        djd 		return stmt;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**Set resultSet defaults to match 
 47119        djd 	 * the statement defaults sent on EXCSQLSTT
 47119        djd 	 * This might be overridden on OPNQRY or CNTQRY
 47119        djd 	 **/
 47119        djd 
 47119        djd 	protected void setRsDefaultOptions(DRDAResultSet drs)
 47119        djd 	{
 47119        djd 		drs.nbrrow = nbrrow;
 47119        djd  		drs.qryrowset = qryrowset;
 47119        djd  		drs.blksize = blksize;
 47119        djd  		drs.maxblkext = maxblkext;
 47119        djd  		drs.outovropt = outovropt;
 47119        djd  		drs.rslsetflg = rslsetflg;
 47119        djd 		drs.scrollType = scrollType;
 47119        djd 		drs.concurType = concurType;
 47119        djd 		drs.setQryprctyp(qryprctyp);
 47119        djd 		drs.qryrowset = qryrowset;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Get the extData Objects
 47119        djd 	 *
 47119        djd 	 *  @return ArrayList with extdta
 47119        djd 	 */
 47119        djd 	protected ArrayList getExtDtaObjects()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getExtDtaObjects();
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Set the extData Objects
 47119        djd 	 */
 47119        djd 	protected void  setExtDtaObjects(ArrayList a)
 47119        djd 	{
 47119        djd 		currentDrdaRs.setExtDtaObjects(a);
 47119        djd 	}
355689   kmarsden 
355689   kmarsden 	public void setSplitQRYDTA(byte []data)
355689   kmarsden 	{
355689   kmarsden 		currentDrdaRs.setSplitQRYDTA(data);
355689   kmarsden 	}
355689   kmarsden 	public byte[]getSplitQRYDTA()
355689   kmarsden 	{
355689   kmarsden 		return currentDrdaRs.getSplitQRYDTA();
355689   kmarsden 	}
 47119        djd 	
 47119        djd    	/**
 47119        djd 	 * Add extDtaObject
 47119        djd 	 * @param o - object to  add
 47119        djd 	 * @param jdbcIndex - jdbc index for parameter
 47119        djd 	 */
 47119        djd 	protected void  addExtDtaObject (Object o, int jdbcIndex )
 47119        djd 	{
 47119        djd 		currentDrdaRs.addExtDtaObject(o,jdbcIndex);
 47119        djd 	}
 47119        djd 
 47119        djd 	
 47119        djd 	/**
 47119        djd 	 * Clear externalized lob objects in current result set
 47119        djd 	 */
 47119        djd 	protected void  clearExtDtaObjects ()
 47119        djd 	{
 47119        djd 		currentDrdaRs.clearExtDtaObjects();
 47119        djd 	}
 47119        djd 
123827   kmarsden 	/**
123827   kmarsden 	 *
391691        djd 	 *  get resultSetHoldability.
123827   kmarsden 	 * 
123827   kmarsden 	 * @return the resultSet holdability for the prepared statement
123827   kmarsden 	 *
123827   kmarsden 	 */
123827   kmarsden 	protected int getResultSetHoldability() throws SQLException
123827   kmarsden 	{
495543   kahatlen 		return getResultSetHoldability(getResultSet());
123827   kmarsden 	}
326718   kmarsden 	
326718   kmarsden 	/**
326718   kmarsden 	 *
391691        djd 	 *  get resultSetHoldability.
326718   kmarsden 	 * 
326718   kmarsden 	 * @param rs ResultSet 
326718   kmarsden 	 * @return the resultSet holdability for the prepared statement
326718   kmarsden 	 *
326718   kmarsden 	 */
391691        djd 	int getResultSetHoldability(ResultSet rs) throws SQLException
326718   kmarsden 	{
391691        djd 		Statement rsstmt;
123827   kmarsden 
326718   kmarsden 		if (rs  != null)
326718   kmarsden 			rsstmt = rs.getStatement();
326718   kmarsden 		else
326718   kmarsden 			rsstmt = getPreparedStatement();
391691        djd         
495543   kahatlen         return rsstmt.getResultSetHoldability();
326718   kmarsden 	}	
326718   kmarsden 
 47119        djd 	/*
 47119        djd 	 * Is lob object nullable
 47119        djd 	 * @param index - offset starting with 0
 47119        djd 	 * @return true if object is nullable
 47119        djd 	 */
 47119        djd 	protected boolean isExtDtaValueNullable(int index)
 47119        djd 	{
 47119        djd 		return currentDrdaRs.isExtDtaValueNullable(index);
 47119        djd 	}
 47119        djd 	
 47119        djd 
 47119        djd 	/**
394859   kahatlen 	 * Set query options sent on OPNQRY and pass options down to the
394859   kahatlen 	 * current <code>DRDAResultSet</code> object.
394859   kahatlen 	 *
394859   kahatlen 	 * @param blksize QRYBLKSZ (Query Block Size)
394859   kahatlen 	 * @param qryblkctl QRYPRCTYP (Query Protocol Type)
394859   kahatlen 	 * @param maxblkext MAXBLKEXT (Maximum Number of Extra Blocks)
394859   kahatlen 	 * @param outovropt OUTOVROPT (Output Override Option)
394859   kahatlen 	 * @param qryrowset QRYROWSET (Query Rowset Size)
394859   kahatlen 	 * @param qryclsimpl QRYCLSIMP (Query Close Implicit)
189752   kmarsden 	 * @see DRDAResultSet#setOPNQRYOptions(int, int, int, int, int, int)
 47119        djd 	 */
 47119        djd 	protected void setOPNQRYOptions(int blksize, int qryblkctl,
 47119        djd 								  int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
 47119        djd 	{
394859   kahatlen 		this.blksize = blksize;
394859   kahatlen 		this.qryprctyp = qryblkctl;
394859   kahatlen 		this.maxblkext = maxblkext;
394859   kahatlen 		this.outovropt = outovropt;
394859   kahatlen 		this.qryrowset = qryrowset;
189752   kmarsden 		currentDrdaRs.setOPNQRYOptions( blksize, qryblkctl, maxblkext, 
189752   kmarsden 				outovropt, qryrowset, qryclsimpl);
 47119        djd 	}
 47119        djd 
 47119        djd 	/*
 47119        djd 	 * Set query options sent on CNTQRY
 47119        djd 	 */
 47119        djd 	protected void setQueryOptions(int blksize, boolean qryrelscr, 
 47119        djd 									long qryrownbr,
 47119        djd 									boolean qryfrtbl,int nbrrow,int maxblkext,
 47119        djd 									int qryscrorn, boolean qryrowsns,
 47119        djd 									boolean qryblkrst,
 47119        djd 									boolean qryrtndta,int qryrowset,
 47119        djd 									int rtnextdta)
 47119        djd 	{
 47119        djd 		currentDrdaRs.blksize = blksize;
 47119        djd 		currentDrdaRs.qryrelscr = qryrelscr;
 47119        djd 		currentDrdaRs.qryrownbr = qryrownbr;
 47119        djd 		currentDrdaRs.qryrfrtbl = qryrfrtbl;
 47119        djd 		currentDrdaRs.nbrrow = nbrrow;
 47119        djd 		currentDrdaRs.maxblkext = maxblkext;
 47119        djd 		currentDrdaRs.qryscrorn = qryscrorn;
 47119        djd 		currentDrdaRs.qryrowsns = qryrowsns;
 47119        djd 		currentDrdaRs.qryblkrst = qryblkrst;
 47119        djd 		currentDrdaRs.qryrtndta = qryrtndta;
 47119        djd 		currentDrdaRs.qryrowset = qryrowset;
 47119        djd 		currentDrdaRs.rtnextdta = rtnextdta;
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 
 47119        djd 	protected void setQryprctyp(int qryprctyp)
 47119        djd 	{
 47119        djd 		this.qryprctyp = qryprctyp;
 47119        djd 		currentDrdaRs.setQryprctyp(qryprctyp);
 47119        djd 	}
 47119        djd 
 47119        djd 	protected int  getQryprctyp()
 47119        djd 		throws SQLException
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getQryprctyp();
 47119        djd 	}
 47119        djd 
 47119        djd 	protected void setQryrownbr(long qryrownbr)
 47119        djd 	{
 47119        djd 		currentDrdaRs.qryrownbr = qryrownbr;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected long  getQryrownbr()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.qryrownbr;
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	protected int  getQryrowset()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.qryrowset;
 47119        djd 	}
 47119        djd 
 47119        djd 	
 47119        djd 	protected int getBlksize()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.blksize;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected void setQryrtndta(boolean qryrtndta)
 47119        djd 	{
 47119        djd 		currentDrdaRs.qryrtndta = qryrtndta;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected boolean  getQryrtndta()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.qryrtndta;
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	protected void setQryscrorn(int qryscrorn)
 47119        djd 	{
 47119        djd 		currentDrdaRs.qryscrorn = qryscrorn;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected int  getQryscrorn()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.qryscrorn;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected void setScrollType(int scrollType)
 47119        djd 	{
 47119        djd 		currentDrdaRs.scrollType = scrollType;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected int  getScrollType()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.scrollType;
 47119        djd 	}
 47119        djd 
123827   kmarsden 	/** 
123827   kmarsden 	 * is this a scrollable cursor?
123827   kmarsden 	 * return true if this is not a forward only cursor
123827   kmarsden 	 */
123827   kmarsden 	protected boolean isScrollable()
123827   kmarsden 	{
123827   kmarsden 		return (getScrollType() != ResultSet.TYPE_FORWARD_ONLY);
123827   kmarsden 	}
 47119        djd 
 47119        djd 	protected void setConcurType(int scrollType)
 47119        djd 	{
 47119        djd 		currentDrdaRs.concurType = scrollType;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected int  getConcurType()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.concurType;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected void 	setOutovr_drdaType(int[] outovr_drdaType) 
 47119        djd 	{
 47119        djd 	   currentDrdaRs.outovr_drdaType = outovr_drdaType;
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	protected int[] 	getOutovr_drdaType() 
 47119        djd 	{
 47119        djd 		return currentDrdaRs.outovr_drdaType;
 47119        djd 	}
 47119        djd 	
 47119        djd 	protected boolean hasdata()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.hasdata;
 47119        djd 	}
 47119        djd 	
 47119        djd 	protected void  setHasdata(boolean hasdata)
 47119        djd 	{
 47119        djd 		currentDrdaRs.hasdata = hasdata;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
381937   kmarsden 	 * This method is used to initialize the default statement of the database
381937   kmarsden 	 * for re-use. It is different from reset() method since default statements
381937   kmarsden 	 * get initiliazed differently. e.g: stmt variable used in default statement
381937   kmarsden 	 * is created only once in Database.makeConnection. 
381937   kmarsden 	 * TODO: Need to see what exactly it means to initialize the default 
381937   kmarsden 	 * statement. (DERBY-1002)
381937   kmarsden 	 * 
 47119        djd 	 */
 47119        djd 	protected void initialize() 
 47119        djd 	{
 47119        djd 		setTypDefValues();
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	protected PreparedStatement explicitPrepare(String sqlStmt) throws SQLException
 47119        djd 	{
 47119        djd 		explicitlyPrepared = true;
 47119        djd 		return prepare(sqlStmt);
 47119        djd 	}
 47119        djd 
 47119        djd 	protected boolean wasExplicitlyPrepared()
 47119        djd 	{
 47119        djd 		return explicitlyPrepared;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Create a prepared statement
 47119        djd 	 *
 47119        djd 	 * @param sqlStmt - SQL statement
 47119        djd 	 *
 47119        djd 	 * @exception SQLException
 47119        djd 	 */
 47119        djd 	protected PreparedStatement prepare(String sqlStmt)   throws SQLException
 47119        djd 	{
 47119        djd 		// save current prepare iso level
 47119        djd 		int saveIsolationLevel = -1;
 47119        djd 		boolean isolationSet = false;
159041   kmarsden 		if (pkgnamcsn !=null && 
159041   kmarsden 			isolationLevel != Connection.TRANSACTION_NONE)
 47119        djd 		{
 47119        djd 			saveIsolationLevel = database.getPrepareIsolation();
 47119        djd 			database.setPrepareIsolation(isolationLevel);
 47119        djd 			isolationSet = true;
 47119        djd 		}
 47119        djd 		
 47119        djd 		if (isCallableSQL(sqlStmt))
 47119        djd 		{
 47119        djd 			isCall = true;
 47119        djd 			ps = database.getConnection().prepareCall(sqlStmt);
 47119        djd 			setupCallableStatementParams((CallableStatement)ps);
 47119        djd 			if (isolationSet)
 47119        djd 				database.setPrepareIsolation(saveIsolationLevel);
 47119        djd 			return ps;
 47119        djd 		}
 47119        djd 		parsePkgidToFindHoldability();
380278        djd 		ps = prepareStatementJDBC3(sqlStmt, scrollType, concurType, 
156229   kmarsden 									   withHoldCursor);
 47119        djd 		// beetle 3849  -  Need to change the cursor name to what
 47119        djd 		// JCC thinks it will be, since there is no way in the 
 47119        djd 		// protocol to communicate the actual cursor name.  JCC keeps 
 47119        djd 		// a mapping from the client cursor names to the DB2 style cursor names
 47119        djd 		if (cursorName != null)//cursorName not null means we are dealing with dynamic pacakges
 47119        djd 			ps.setCursorName(cursorName);
 47119        djd 		if (isolationSet)
 47119        djd 			database.setPrepareIsolation(saveIsolationLevel);
 47119        djd 				return ps;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Get prepared statement
 47119        djd 	 *
 47119        djd 	 * @return prepared statement
 47119        djd 	 */
126392   kmarsden 	protected PreparedStatement getPreparedStatement() throws SQLException
 47119        djd 	{
421435    davidvc 		return ps;
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Executes the prepared statement and populates the resultSetTable.
 47119        djd 	 * Access to the various resultSets is then possible by using
 47119        djd 	 * setCurrentDrdaResultSet(String pkgnamcsn)  to set the current
 47119        djd 	 * resultSet and then calling getResultSet() or the other access 
 47119        djd 	 * methods to get resultset data.
 47119        djd 	 *
126257 fuzzylogic 	 * @return true if the execution has resultSets
 47119        djd 	 */
 47119        djd 	protected boolean execute() throws SQLException
 47119        djd 	{
 47119        djd 		boolean hasResultSet = ps.execute();
581031   kmarsden 		// DERBY-3085 - We need to make sure we drain the streamed parameter
581031   kmarsden 		// if not used by the server, for example if an update statement does not 
581031   kmarsden 		// update any rows, the parameter won't be used.  Network Server will
581031   kmarsden 		// stream only the last parameter with an EXTDTA. This is stored when the
581031   kmarsden 		// parameter is set and drained now after statement execution if needed.
581031   kmarsden 		try {
581031   kmarsden 			drdaParamState_.drainStreamedParameter();
581031   kmarsden 		} catch (IOException e) { 
581031   kmarsden 			Util.javaException(e);
581031   kmarsden 		}
 47119        djd 		// java.sql.Statement says any result sets that are opened
 47119        djd 		// when the statement is re-executed must be closed; this
 47119        djd 		// is handled by the call to "ps.execute()" above--but we
 47119        djd 		// also have to reset our 'numResultSets' counter, since
 47119        djd 		// all previously opened result sets are now invalid.
 47119        djd 		numResultSets = 0;
 47119        djd 
 47119        djd 		ResultSet rs = null;
 47119        djd 		boolean isCallable = (ps instanceof java.sql.CallableStatement);
 47119        djd 		if (isCallable)
 47119        djd 			needsToSendParamData = true;
 47119        djd 
 47119        djd 		do {
 47119        djd 			rs = ps.getResultSet();
 47119        djd 			if (rs !=null)
 47119        djd 			{
326718   kmarsden 				//For callable statement, get holdability of statement generating the result set
326718   kmarsden 				if(isCallable)
326718   kmarsden 					addResultSet(rs,getResultSetHoldability(rs));
326718   kmarsden 				else
326718   kmarsden 					addResultSet(rs,withHoldCursor);
 47119        djd 				hasResultSet = true;
 47119        djd 			}
 47119        djd 			// For normal selects we are done, but procedures might
 47119        djd 			// have more resultSets
123827   kmarsden 		}while (isCallable && getMoreResults(JDBC30Translation.KEEP_CURRENT_RESULT));
 47119        djd 
 47119        djd 		return hasResultSet;
 47119        djd 
 47119        djd 	}
 47119        djd 	
 47119        djd 	/**
 47119        djd 	 * clear out type data for parameters.
 47119        djd 	 * Unfortunately we currently overload the resultSet type info
 47119        djd 	 * rsDRDATypes et al with parameter info.
 47119        djd 	 * RESOLVE: Need to separate this
 47119        djd 	 */
 47119        djd    protected void finishParams()
 47119        djd 	{
 47119        djd 		needsToSendParamData = false;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Set the pkgid sec num for this statement and the 
 47119        djd 	 * consistency token that will be used for the first resultSet.
 47119        djd 	 * For dyamic packages The package name is encoded as follows
 47119        djd 	 * SYS(S/L)(H/N)xyy 
 47119        djd 	 * where 'S' represents Small package and 'L' large 
515793 fuzzylogic 	 *                      (ignored by Derby) 
 47119        djd 	 * Where 'H' represents WITH HOLD, and 'N' represents NO WITH HOLD. 
 47119        djd 	 *                      (May be overridden by SQLATTR for WITH
 47119        djd 	 *                       HOLD")
 47119        djd 	 *
515793 fuzzylogic 	 * Where 'www' is the package iteration (ignored by Derby)
 47119        djd 	 * Where 'x' is the isolation level: 0=NC, 1=UR, 2=CS, 3=RS, 4=RR 
 47119        djd 	 * Where 'yy' is the package iteration 00 through FF 
 47119        djd 	 * Where 'zz' is unique for each platform
515793 fuzzylogic 	 * Happilly, these values correspond precisely to the internal Derby
 47119        djd 	 * isolation levels  in ExecutionContext.java
 47119        djd 	 * x   Isolation Level                                           
 47119        djd 	 * --  ---------------------
 47119        djd 	 * 0   NC  (java.sql.Connection.TRANSACTION_NONE)
 47119        djd 	 * 1   UR  (java.sql.Connection.TRANACTION_READ_UNCOMMITTED)
 47119        djd 	 * 2   CS  (java.sql.Connection.TRANSACTION_READ_COMMITTED)
 47119        djd 	 * 3   RS  (java.sql.Connection.TRANSACTION_REPEATABLE_READ)
 47119        djd 	 * 4   RR  (java.sql.Connection.TRANSACTION_SERIALIZABLE)
 47119        djd 	 * 
 47119        djd 	 * static packages have preset isolation levels 
 47119        djd 	 * (see getStaticPackageIsolation)
 47119        djd 	 * @param pkgnamcsn  package id section number and token from the client
 47119        djd 	 */
368333      bernt 	protected void setPkgnamcsn(Pkgnamcsn pkgnamcsn)
 47119        djd 	{
 47119        djd 		this.pkgnamcsn =  pkgnamcsn;
 47119        djd 		// Store the consistency string for the first ResultSet.
 47119        djd 		// this will be used to calculate consistency strings for the 
 47119        djd 		// other result sets.
368333      bernt 		pkgid = pkgnamcsn.getPkgid();
 47119        djd 
 47119        djd 		if (isDynamicPkgid(pkgid))
 47119        djd 		{
 47119        djd 			isolationLevel = Integer.parseInt(pkgid.substring(5,6));
 47119        djd 			
 47119        djd 			
 47119        djd 			/*
 47119        djd 			 *   generate DB2-style cursorname
 47119        djd 			 *   example value : SQL_CURSN200C1
 47119        djd 			 *   where 
 47119        djd 			 *      SQL_CUR is db2 cursor name prefix;
 47119        djd 			 *      S - Small package , L -Large package
 47119        djd 			 *      N - normal cursor, H - hold cursor 
 47119        djd 			 *      200 - package id as sent by jcc 
 47119        djd 			 *      C - tack-on code for cursors
 47119        djd 			 *      1 - section number sent by jcc		 
 47119        djd 			 */
 47119        djd 			
 47119        djd 			
 47119        djd 
 47119        djd 			// cursor name
 47119        djd 			// trim the SYS off the pkgid so it wont' be in the cursor name
 47119        djd 			String shortPkgid = pkgid.substring(pkgid.length() -5 , pkgid.length());
368333      bernt 			pkgsn = pkgnamcsn.getPkgsn();
368333      bernt 			this.cursorName = "SQL_CUR" +  shortPkgid + "C" + pkgsn ;
 47119        djd 		}
 47119        djd 		else // static package
 47119        djd 		{
 47119        djd 			isolationLevel = getStaticPackageIsolation(pkgid);
 47119        djd 		}
 47119        djd 
368333      bernt 		this.pkgcnstkn = pkgnamcsn.getPkgcnstkn();
 47119        djd 
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * get the isolation level for a static package.
 47119        djd 	 * @param pkgid - Package identifier string (e.g. SYSSTAT)
 47119        djd 	 * @return isolation
 47119        djd 	 */
 47119        djd 	private int getStaticPackageIsolation(String pkgid)
 47119        djd 	{
 47119        djd 		// SYSSTAT is used for metadata. and is the only static package used
 47119        djd 		// for JCC. Other static packages will need to be supported for 
 47119        djd 		// CCC. Maybe a static hash table would then be in order.
 47119        djd 		if (pkgid.equals("SYSSTAT"))
 47119        djd 			return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;
 47119        djd 		else
 47119        djd 			return ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Get pkgnamcsn
 47119        djd 	 *
 47119        djd 	 * @return pkgnamcsn
 47119        djd 	 */
368333      bernt 	protected Pkgnamcsn getPkgnamcsn() 
 47119        djd 	{
 47119        djd 		return pkgnamcsn;
 47119        djd 
 47119        djd 	}
 47119        djd 	/**
 47119        djd 	 * Get result set
 47119        djd 	 *
 47119        djd 	 * @return result set
 47119        djd 	 */
 47119        djd 	protected ResultSet getResultSet() 
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getResultSet();
 47119        djd 	}
 47119        djd 
 47119        djd 	
 47119        djd 	/** 
 47119        djd 	 * Just get the resultset. Don't set it to current
 47119        djd 	 * Assumes resultSet rsnum exists.
 47119        djd 	 *
126257 fuzzylogic 	 * @param rsNum resultSetNumber starting with 0
 47119        djd 	 * @return  The result set in the order it was retrieved
 47119        djd 	 *         
 47119        djd 	 *          with getMoreResults()
 47119        djd 	 **/
 47119        djd 	private  ResultSet getResultSet(int rsNum)  
 47119        djd 	{
 47119        djd 		if (rsNum == 0)
 47119        djd 			return currentDrdaRs.getResultSet();
 47119        djd 		else
 47119        djd 		{
368333      bernt 			ConsistencyToken key = (ConsistencyToken) resultSetKeyList.get(rsNum);
 47119        djd 			return ((DRDAResultSet) (resultSetTable.get( key))).getResultSet();
 47119        djd 		}
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd  	 * Set result set
 47119        djd 	 *
 47119        djd 	 * @param value
 47119        djd 	 */
 47119        djd 	protected void setResultSet(ResultSet value) throws SQLException
 47119        djd 	{
 47119        djd 		if (currentDrdaRs.getResultSet() == null)
 47119        djd 			numResultSets = 1;
 47119        djd 		currentDrdaRs.setResultSet(value);
 47119        djd 		setRsDefaultOptions(currentDrdaRs);
 47119        djd 	}
326718   kmarsden 	
326718   kmarsden 	/**
326718   kmarsden 	 * Gets the current DRDA ResultSet
326718   kmarsden 	 * 
326718   kmarsden 	 * @return DRDAResultSet
326718   kmarsden 	 */
326718   kmarsden 	protected DRDAResultSet getCurrentDrdaResultSet()
326718   kmarsden 	{
326718   kmarsden 		return currentDrdaRs ;
326718   kmarsden 	}
 47119        djd 
 47119        djd 	/**
 47119        djd  	 * Set currentDrdaResultSet 
 47119        djd 	 *
 47119        djd 	 * @param rsNum   The result set number starting with 0
 47119        djd 	 *                 
 47119        djd 	 */
 47119        djd 	protected void setCurrentDrdaResultSet(int rsNum)
 47119        djd 	{
368333      bernt 		ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
368333      bernt 		if (currentDrdaRs.pkgcnstkn == consistToken)
 47119        djd 			return;
 47119        djd 		currentDrdaRs = getDrdaResultSet(consistToken);
 47119        djd 
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd  	 * Set currentDrdaResultSet 
 47119        djd 	 *
126257 fuzzylogic 	 * @param pkgnamcsn  The pkgid section number and unique resultset
 47119        djd 	 *                    consistency token
 47119        djd 	 *                 
 47119        djd 	 */
368333      bernt 	protected void setCurrentDrdaResultSet(Pkgnamcsn pkgnamcsn)
 47119        djd 	{
368333      bernt 		pkgid = pkgnamcsn.getPkgid();
368333      bernt 		pkgsn = pkgnamcsn.getPkgsn();
368333      bernt 		ConsistencyToken consistToken = pkgnamcsn.getPkgcnstkn();
 47119        djd 		DRDAResultSet newDrdaRs = getDrdaResultSet(consistToken);
 47119        djd 		if (newDrdaRs != null)
 47119        djd 			currentDrdaRs = newDrdaRs;
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	/*
 47119        djd 	 * get DRDAResultSet by consistency token
 47119        djd 	 *
 47119        djd 	 */
368333      bernt 	private DRDAResultSet getDrdaResultSet(ConsistencyToken consistToken)
 47119        djd 	{
 47119        djd 		if ( resultSetTable   == null || 
 47119        djd 			 (currentDrdaRs != null &&
368333      bernt 			  currentDrdaRs.pkgcnstkn == consistToken ))
 47119        djd 		{
 47119        djd 			return currentDrdaRs;
 47119        djd 		}
 47119        djd 		else
 47119        djd 		{
 47119        djd 			return (DRDAResultSet) (resultSetTable.get(consistToken));
 47119        djd 		}
 47119        djd 	}
 47119        djd 	
 47119        djd 	/*
 47119        djd 	 * get DRDAResultSet by result set number
 47119        djd 	 *
 47119        djd 	 */
 47119        djd 	private DRDAResultSet getDrdaResultSet(int rsNum)
 47119        djd 	{
368333      bernt 		ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
 47119        djd 		return getDrdaResultSet(consistToken);
 47119        djd 	}
 47119        djd 
 47119        djd 	/** Add a new resultSet to this statement.
 47119        djd 	 * Set as the current result set if  there is not an 
 47119        djd 	 * existing current resultset.
 47119        djd 	 * @param value - ResultSet to add
326718   kmarsden 	 * @param holdValue - Holdability of the ResultSet 
 47119        djd 	 * @return    Consistency token  for this resultSet
 47119        djd 	 *            For a single resultSet that is the same as the statement's 
 47119        djd 	 *            For multiple resultSets just the consistency token is changed 
 47119        djd 	 */
368333      bernt 	protected ConsistencyToken addResultSet(ResultSet value, int holdValue) throws SQLException
 47119        djd 	{
 47119        djd 
 47119        djd 		DRDAResultSet newDrdaRs = null;
 47119        djd 
 47119        djd 		int rsNum = numResultSets;
368333      bernt 		ConsistencyToken newRsPkgcnstkn = calculateResultSetPkgcnstkn(rsNum);
 47119        djd 
 47119        djd 		if (rsNum == 0)
 47119        djd 			newDrdaRs = currentDrdaRs;
 47119        djd 
 47119        djd 		else
 47119        djd 		{
 47119        djd 			newDrdaRs = new DRDAResultSet();
 47119        djd 
 47119        djd 			// Multiple resultSets we neeed to setup the hash table
 47119        djd 			if (resultSetTable == null)
 47119        djd 			{
 47119        djd 				// If hashtable doesn't exist, create it and store resultSet 0
 47119        djd 				// before we store our new resultSet.
 47119        djd 				// For just a single resultSet we don't ever create the Hashtable.
 47119        djd 				resultSetTable = new Hashtable();
368333      bernt 				resultSetTable.put(pkgcnstkn, currentDrdaRs);
 47119        djd 				resultSetKeyList = new ArrayList();
368333      bernt 				resultSetKeyList.add(0, pkgcnstkn);
 47119        djd 			}
 47119        djd 
368333      bernt 			resultSetTable.put(newRsPkgcnstkn, newDrdaRs);
368333      bernt 			resultSetKeyList.add(rsNum, newRsPkgcnstkn);
 47119        djd 		}
 47119        djd 
 47119        djd 		newDrdaRs.setResultSet(value);
368333      bernt 		newDrdaRs.setPkgcnstkn(newRsPkgcnstkn);
326718   kmarsden 		newDrdaRs.withHoldCursor = holdValue;
 47119        djd 		setRsDefaultOptions(newDrdaRs);
 47119        djd 		newDrdaRs.suspend();
 47119        djd 		numResultSets++;
368333      bernt 		return newRsPkgcnstkn;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 *
 47119        djd 	 * @return 	number of result sets
 47119        djd 	 */
 47119        djd 	protected int getNumResultSets()
 47119        djd 	{
 47119        djd 		return numResultSets;
 47119        djd 	}
 47119        djd 	
 47119        djd 	
 47119        djd 	/**
 47119        djd 	 * @param rsNum result set starting with 0
 47119        djd 	 * @return  consistency token (key) for the result set	 
 47119        djd 	 */
368333      bernt 	protected ConsistencyToken getResultSetPkgcnstkn(int rsNum)
 47119        djd 	{
 47119        djd 		if (rsNum == 0)
368333      bernt 			return pkgcnstkn;
 47119        djd 		else 
368333      bernt 			return (ConsistencyToken) resultSetKeyList.get(rsNum);			   
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	/** 
 47119        djd 	 * Set ResultSet DRDA DataTypes
126257 fuzzylogic 	 * @param value drdaTypes for columns.
 47119        djd 	 **/
 47119        djd 	protected void setRsDRDATypes(int [] value)
 47119        djd 	{
 47119        djd 		currentDrdaRs.setRsDRDATypes(value);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 *@return ResultSet DRDA DataTypes
 47119        djd 	 **/
 47119        djd 
 47119        djd 	protected int[] getRsDRDATypes()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getRsDRDATypes();
 47119        djd 
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	/** 
 47119        djd 	 * Set ResultSet DRDA DataTypes Lengths
126257 fuzzylogic 	 * @param value drdaTypes for columns.
 47119        djd 	 **/
 47119        djd 	protected void setRsLens(int [] value)
 47119        djd 	{
 47119        djd 		currentDrdaRs.rsLens = value;
 47119        djd 
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 *@return ResultSet DRDA DataTypes Lengths
 47119        djd 	 **/
 47119        djd 
 47119        djd 	protected int[] getRsLens()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.rsLens;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 *  Close the current resultSet
 47119        djd 	 */
 47119        djd 	protected void rsClose() throws SQLException
 47119        djd 	{
 47119        djd 		if (currentDrdaRs.getResultSet() == null) 
 47119        djd 			return;
 47119        djd 
 47119        djd 		currentDrdaRs.close();
 47119        djd 		needsToSendParamData = false;		
 47119        djd 		numResultSets--;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * Explicitly close the result set by CLSQRY
 47119        djd 	 * needed to check for double close.
 47119        djd 	 */
 47119        djd 	protected void CLSQRY()
 47119        djd 	{
 47119        djd 		currentDrdaRs.CLSQRY();
 47119        djd 	}
 47119        djd 
 47119        djd 	/* 
 47119        djd 	 * @return whether CLSQRY has been called on the
 47119        djd 	 *         current result set.
 47119        djd 	 */
 47119        djd 	protected boolean wasExplicitlyClosed()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.wasExplicitlyClosed();
 47119        djd 	}
 47119        djd 
381937   kmarsden 	/**
381937   kmarsden 	 * This method closes the JDBC objects and frees up all references held by
381937   kmarsden 	 * this object.
 47119        djd 	 * 
381937   kmarsden 	 * @throws SQLException
 47119        djd 	 */
 47119        djd 	protected void close()  throws SQLException
 47119        djd 	{
 47119        djd 		if (ps != null)
 47119        djd 			ps.close();
 47119        djd 		if (stmt != null)
 47119        djd 			stmt.close();
381937   kmarsden 		currentDrdaRs.close();
 47119        djd 		resultSetTable = null;
 47119        djd 		resultSetKeyList = null;
 47119        djd 		ps = null;
123827   kmarsden 		stmtPmeta = null;
 47119        djd 		stmt = null;
381937   kmarsden 		rslsetflg = null;
381937   kmarsden 		procName = null;
381937   kmarsden 		outputTypes = null;
534985   kmarsden 		outputPrecision = null;
534985   kmarsden 		outputScale = null;
467612   kahatlen 		// Clear parameters and release excess storage
467612   kahatlen 		drdaParamState_.clear(true);
381937   kmarsden 	}
381937   kmarsden 	
381937   kmarsden 	/**
381937   kmarsden 	 * This method resets the state of this DRDAStatement object so that it can
381937   kmarsden 	 * be re-used. This method should reset all variables of this class except 
381937   kmarsden 	 * the following:
381937   kmarsden      * 1. database - This variable gets initialized in the constructor and by
381937   kmarsden      * call to setDatabase.
381937   kmarsden      * 2. members which get initialized in setPkgnamcsn (pkgnamcsn, pkgcnstkn, 
381937   kmarsden      * pkgid, pkgsn, isolationLevel, cursorName). pkgnamcsn is the key used to 
381937   kmarsden      * find if the DRDAStatement can be re-used. Hence its value will not change 
381937   kmarsden      * when the object is re-used.
381937   kmarsden 	 * 
381937   kmarsden 	 */
381937   kmarsden 	protected void reset() 
381937   kmarsden 	{
381937   kmarsden 		setTypDefValues();
381937   kmarsden 		
381937   kmarsden 		withHoldCursor = -1;
123827   kmarsden 		scrollType = ResultSet.TYPE_FORWARD_ONLY;	
123827   kmarsden 		concurType = ResultSet.CONCUR_READ_ONLY;;
 47119        djd 		rowCount = 0;
 47119        djd 		rslsetflg = null;
 47119        djd 		maxrslcnt = 0;
381937   kmarsden 		ps = null;
381937   kmarsden 		stmtPmeta = null;
381937   kmarsden 		isCall = false;
 47119        djd 		procName = null;
 47119        djd 		outputTypes = null;
 47119        djd 		outputExpected = false;
381937   kmarsden 		stmt = null;
381937   kmarsden 		
381937   kmarsden 		currentDrdaRs.reset();
381937   kmarsden 		resultSetTable = null;
381937   kmarsden 		resultSetKeyList = null;
381937   kmarsden 		numResultSets = 0;
381937   kmarsden 		
467612   kahatlen 		// Clear parameters without releasing storage
467612   kahatlen 		drdaParamState_.clear(false);
381937   kmarsden 		
381937   kmarsden 		nbrrow = 0;
381937   kmarsden 		qryrowset = 0;	
381937   kmarsden 		blksize = 0;		
381937   kmarsden 		maxblkext = 0;	
381937   kmarsden 		outovropt = 0;	
381937   kmarsden 		qryrfrtbl = false;
381937   kmarsden 		qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;
374029      bernt 
381937   kmarsden 		needsToSendParamData = false;
381937   kmarsden 		explicitlyPrepared = false;
381937   kmarsden 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * is Statement closed
 47119        djd 	 * @return whether the statement is closed
 47119        djd 	 */
 47119        djd 	protected boolean rsIsClosed()
 47119        djd 	{
 47119        djd 		return currentDrdaRs.isClosed();
 47119        djd 	}
 47119        djd 	
 47119        djd 	/**
 47119        djd 	 * Set state to SUSPENDED (result set is opened)
 47119        djd 	 */
 47119        djd 	protected void rsSuspend()
 47119        djd 	{
 47119        djd 		currentDrdaRs.suspend();
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * set resultset/out parameter precision
 47119        djd 	 *
 47119        djd 	 * @param index - starting with 1
 47119        djd 	 * @param precision
 47119        djd 	 */
 47119        djd 	protected void setRsPrecision(int index, int precision)
 47119        djd 	{
 47119        djd 		currentDrdaRs.setRsPrecision(index,precision);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * get resultset /out paramter precision
 47119        djd 	 * @param index -starting with 1
 47119        djd 	 * @return precision of column
 47119        djd 	 */
 47119        djd 	protected int getRsPrecision(int index)
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getRsPrecision(index);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * set resultset/out parameter scale
 47119        djd 	 *
 47119        djd 	 * @param index - starting with 1
 47119        djd 	 * @param scale
 47119        djd 	 */
 47119        djd 	protected void setRsScale(int index, int scale)
 47119        djd 	{
 47119        djd 		currentDrdaRs.setRsScale(index, scale);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * get resultset /out paramter scale
 47119        djd 	 * @param index -starting with 1
 47119        djd 	 * @return scale of column
 47119        djd 	 */
 47119        djd 	protected int  getRsScale(int index)
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getRsScale(index);
 47119        djd 	}
 47119        djd 	
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * set result  DRDAType
 47119        djd 	 *
 47119        djd 	 * @param index - starting with 1
 47119        djd 	 * @param type
 47119        djd 	 */
 47119        djd 	protected  void setRsDRDAType(int index, int type)
 47119        djd 	{
 47119        djd 		currentDrdaRs.setRsDRDAType(index,type);
 47119        djd 		
 47119        djd 	}
 47119        djd 
467612   kahatlen 	/** Clears the parameter state (type, length and ext information)
467612   kahatlen 	 * stored in this statement, but does not release any
467612   kahatlen 	 * storage. This reduces the cost of re-executing the statement
467612   kahatlen 	 * since no new storage needs to be allocated. */
467612   kahatlen 	protected void clearDrdaParams() {
467612   kahatlen 		drdaParamState_.clear(false);
467612   kahatlen 	}
467612   kahatlen 
467612   kahatlen 	/** Get the number of external parameters in this
467612   kahatlen 	 * statement. External means parameters that are transmitted in a
467612   kahatlen 	 * separate DSS in the DRDA protocol.
467612   kahatlen 	 * @return the number of external parameters
 47119        djd 	 */
467612   kahatlen 	protected int getExtPositionCount() {
467612   kahatlen 		return drdaParamState_.getExtPosCount();
 47119        djd 	}
 47119        djd 
467612   kahatlen 	/** Get the parameter position of the i'th external parameter
467612   kahatlen 	 * @param i - zero-based index into list of external parameters
467612   kahatlen 	 * @return the parameter position of the i'th external parameter
467612   kahatlen 	 */
467612   kahatlen 	protected int getExtPosition(int i) {
467612   kahatlen 		return drdaParamState_.getExtPos(i);
467612   kahatlen 	}
 47119        djd 
467612   kahatlen 	/** Mark the pos'th parameter as external
467612   kahatlen 	 * @param pos - zero-based index into list of external parameters
467612   kahatlen 	 */
467612   kahatlen 	protected void addExtPosition(int pos) {
467612   kahatlen 		drdaParamState_.addExtPos(pos);
467612   kahatlen 	}
467612   kahatlen 
467612   kahatlen 	/** Get the number of parameters, internal and external, that has
467612   kahatlen 	 * been added to this statement.
467612   kahatlen 	 * @return the number of parameters
467612   kahatlen 	 */
467612   kahatlen 	protected int getDrdaParamCount() {
467612   kahatlen 		return drdaParamState_.getDrdaParamCount();
467612   kahatlen 	}
467612   kahatlen 
467612   kahatlen 	/** Add another parameter to this statement.
467612   kahatlen 	 * @param t - type of the parameter
467612   kahatlen 	 * @param l - length in bytes of the parameter
467612   kahatlen 	 */
467612   kahatlen 	protected void addDrdaParam(byte t, int l) {
467612   kahatlen 		drdaParamState_.addDrdaParam(t, l);
467612   kahatlen 	}
467612   kahatlen 
581031   kmarsden     protected void setStreamedParameter(EXTDTAReaderInputStream eis)
581031   kmarsden     {
581031   kmarsden         drdaParamState_.setStreamedParameter(eis);
581031   kmarsden     }
581031   kmarsden     
 47119        djd 	/**
467612   kahatlen 	 * get parameter DRDAType
 47119        djd 	 *
 47119        djd 	 * @param index - starting with 1
467612   kahatlen 	 * @return  DRDA Type of column
 47119        djd 	 */
467612   kahatlen  	protected int getParamDRDAType(int index) {
467612   kahatlen 		return drdaParamState_.getDrdaType(index-1);
467612   kahatlen  	}
467612   kahatlen 
 47119        djd 	/**
 47119        djd 	 * returns drda length of parameter as sent by client.
467612   kahatlen 	 * @param index - starting with 1
 47119        djd 	 * @return data length
 47119        djd 
 47119        djd 	 */
 47119        djd 	protected int getParamLen(int index)
 47119        djd 	{
467612   kahatlen 		return drdaParamState_.getDrdaLen(index-1);
 47119        djd 	}
467612   kahatlen 
467612   kahatlen 
 47119        djd 	/**
 47119        djd 	 *  get parameter precision or DB2 max (31)
 47119        djd 	 *
 47119        djd 	 *  @param index parameter index starting with 1
 47119        djd 	 *
 47119        djd 	 *  @return  precision
 47119        djd 	 */
 47119        djd 	protected int getParamPrecision(int index) throws SQLException
 47119        djd 	{
 47119        djd 		if (ps != null && ps instanceof CallableStatement)
 47119        djd 		{
495543   kahatlen 			ParameterMetaData pmeta = getParameterMetaData();
123827   kmarsden 
 47119        djd 			return Math.min(pmeta.getPrecision(index),
 47119        djd 							FdocaConstants.NUMERIC_MAX_PRECISION);
 47119        djd 
 47119        djd 		}
 47119        djd 		else 
 47119        djd 			return -1;
 47119        djd 	}
 47119        djd 	
 47119        djd 	/**
 47119        djd 	 *  get parameter scale or DB2 max (31)
 47119        djd 	 *
 47119        djd 	 *  @param index parameter index starting with 1
 47119        djd 	 *
 47119        djd 	 *  @return  scale
 47119        djd 	 */
 47119        djd 	protected int getParamScale(int index) throws SQLException
 47119        djd 	{
 47119        djd 		if (ps != null && ps instanceof CallableStatement)
 47119        djd 		{
495543   kahatlen 			ParameterMetaData pmeta = getParameterMetaData();
 47119        djd 			return Math.min(pmeta.getScale(index),FdocaConstants.NUMERIC_MAX_PRECISION);
 47119        djd 		}
 47119        djd 		else 
 47119        djd 			return -1;
 47119        djd 	}
 47119        djd 
 47119        djd 	/** 
 47119        djd 	 * get the number of result set columns for the current resultSet
 47119        djd 	 * 
 47119        djd 	 * @return number of columns
 47119        djd 	 */
 47119        djd 
 47119        djd 	protected int getNumRsCols()
 47119        djd 	{
348577   kmarsden 		int[] rsDrdaTypes = getRsDRDATypes();
 47119        djd 		if (rsDrdaTypes != null)
 47119        djd 			return rsDrdaTypes.length;
 47119        djd 		else 
 47119        djd 			return 0;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * get  resultset/out parameter DRDAType
 47119        djd 	 *
 47119        djd 	 * @param index - starting with 1
 47119        djd 	 * @return  DRDA Type of column
 47119        djd 	 */
 47119        djd 	protected int getRsDRDAType(int index)
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getRsDRDAType(index);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * get resultset/out parameter DRDALen
 47119        djd 	 * @param index starting with 1
 47119        djd 	 * 
 47119        djd 	 * @return length of drda data
 47119        djd 	 */
 47119        djd 	 
 47119        djd 	protected int getRsLen(int index)
 47119        djd 	{
 47119        djd 		return currentDrdaRs.getRsLen(index);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * set resultset column data length
 47119        djd 	 * @param index starting with 1
126257 fuzzylogic 	 * @param value length
 47119        djd 	 */
 47119        djd 	protected void  setRsLen(int index, int value)
 47119        djd 	{
 47119        djd 		currentDrdaRs.setRsLen(index,value);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * @param rsNum  - result set # starting with 0 
 47119        djd 	 */
 47119        djd 	public String getResultSetCursorName(int rsNum) throws SQLException
 47119        djd 	{
348577   kmarsden 		DRDAResultSet drdaRs = getDrdaResultSet(rsNum);
348577   kmarsden 		return drdaRs.getResultSetCursorName();			
 47119        djd 
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 	protected String toDebugString(String indent)
 47119        djd 	{
 47119        djd 		ResultSet rs = currentDrdaRs.getResultSet();
 47119        djd 		
 47119        djd 		String s ="";
 47119        djd 		if (ps == null) 
 47119        djd 			s += indent + ps;
 47119        djd 		else
 47119        djd 		{
368333      bernt 			s += indent + pkgid + pkgsn ;
123827   kmarsden 			s += "\t" + getSQLText();
 47119        djd 		}
 47119        djd 		return s;
 47119        djd 	}
 47119        djd 
 47119        djd 	/**  For a single result set, just echo the consistency token that the client sent us.
 47119        djd 	 * For subsequent resultSets, just subtract the resultset number from
 47119        djd 	 * the consistency token and that will differentiate the result sets.
 47119        djd 	 * This seems to be what DB2 does
 47119        djd 	 * @param rsNum  - result set # starting with 0
 47119        djd 	 * 
 47119        djd 	 * @return  Consistency token for result set
 47119        djd 	 */
 47119        djd 
368333      bernt 	protected ConsistencyToken calculateResultSetPkgcnstkn(int rsNum)
 47119        djd 	{	
368333      bernt 		ConsistencyToken consistToken = pkgcnstkn;
 47119        djd 
368333      bernt 		if (rsNum == 0 || pkgcnstkn == null)
 47119        djd 			return consistToken;
 47119        djd 		else
 47119        djd 		{
368333      bernt 			BigInteger consistTokenBi =
368333      bernt 				new BigInteger(consistToken.getBytes());
368333      bernt 			BigInteger rsNumBi = BigInteger.valueOf(rsNum);
368333      bernt 			consistTokenBi = consistTokenBi.subtract(rsNumBi);
368333      bernt 			consistToken = new ConsistencyToken(consistTokenBi.toByteArray());
 47119        djd 		}
 47119        djd 		return consistToken;
 47119        djd 	}
 47119        djd 
 47119        djd 	protected boolean isCallableStatement()
 47119        djd 	{
 47119        djd 		return isCall;
 47119        djd 	}
 47119        djd 
 47119        djd 	private boolean isCallableSQL(String sql)
 47119        djd 	{
 47119        djd 		java.util.StringTokenizer tokenizer = new java.util.StringTokenizer
 47119        djd 			(sql, "\t\n\r\f=? (");
 47119        djd 		 String firstToken = tokenizer.nextToken();
 47119        djd 		 if (StringUtil.SQLEqualsIgnoreCase(firstToken, 
 47119        djd 											"call")) // captures CALL...and ?=CALL...
 47119        djd 			 return true;
 47119        djd 		 return false;
 47119        djd 				 
 47119        djd 	}
 47119        djd 
 47119        djd 	private void setupCallableStatementParams(CallableStatement cs) throws SQLException
 47119        djd 	{
495543   kahatlen 		ParameterMetaData pmeta = getParameterMetaData();
 47119        djd 		int numElems = pmeta.getParameterCount();
 47119        djd 
 47119        djd 		for ( int i = 0; i < numElems; i ++)
 47119        djd 		{
 47119        djd 			boolean outputFlag = false;
 47119        djd 			
 47119        djd 			int parameterMode = pmeta.getParameterMode(i + 1);
 47119        djd 			int parameterType = pmeta.getParameterType(i + 1);
534985   kmarsden                         int parameterPrecision = pmeta.getPrecision(i + 1);
534985   kmarsden                         int parameterScale = pmeta.getScale(i + 1);
 47119        djd 
 47119        djd 			switch (parameterMode) {
 47119        djd 				case JDBC30Translation.PARAMETER_MODE_IN:
 47119        djd 					break;
 47119        djd 				case JDBC30Translation.PARAMETER_MODE_OUT:
 47119        djd 				case JDBC30Translation.PARAMETER_MODE_IN_OUT:
 47119        djd 					outputFlag = true;
 47119        djd 					break;
 47119        djd 				case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
 47119        djd 					// It's only unknown if array
 47119        djd 					String objectType = pmeta.getParameterClassName(i+1);
 47119        djd 					parameterType =
 47119        djd 						getOutputParameterTypeFromClassName(objectType);
 47119        djd 					if (parameterType  != NOT_OUTPUT_PARAM)
 47119        djd 						outputFlag = true;
 47119        djd 			}
 47119        djd 
 47119        djd 			if (outputFlag)
 47119        djd 			{
 47119        djd 				if (outputTypes == null) //not initialized yet, since previously none output
 47119        djd 				{
 47119        djd 					outputTypes = new int[numElems];
534985   kmarsden 					outputPrecision = new int [numElems];
534985   kmarsden 					outputScale = new int [numElems];
534985   kmarsden 					for (int j = 0; j < numElems; j++) {
 47119        djd 						outputTypes[j] = NOT_OUTPUT_PARAM;  //default init value
534985   kmarsden 						outputPrecision[j] = NOT_OUTPUT_PARAM;
534985   kmarsden 						outputScale[j] = NOT_OUTPUT_PARAM;
534985   kmarsden 					}
 47119        djd 				}
 47119        djd 				// save the output type so we can register when we parse
 47119        djd 				// the SQLDTA
 47119        djd 				outputTypes[i] = parameterType;
534985   kmarsden 				outputPrecision[i] = parameterPrecision;
534985   kmarsden 				outputScale[i] = parameterScale;                
 47119        djd 			}
 47119        djd 			
 47119        djd 		}
 47119        djd 	}
 47119        djd 
 47119        djd 
 47119        djd 
 47119        djd 	/** 
 47119        djd 		Given an object class  name get the paramameter type if the 
 47119        djd 		parameter mode is unknown.
 47119        djd 		
 47119        djd 		Arrays except for byte arrrays are assumed to be output parameters
 47119        djd 		TINYINT output parameters are going to be broken because there
 47119        djd 		is no way to differentiate them from binary input parameters.
 47119        djd 		@param objectName Class name of object being evaluated.
 47119        djd 		indicating if this an output parameter
 47119        djd 		@return type from java.sql.Types
 47119        djd 	**/
 47119        djd 	
 47119        djd 	protected static int getOutputParameterTypeFromClassName(String
 47119        djd 																	objectName)
 47119        djd 	{
 47119        djd 		
 47119        djd 		if (objectName.endsWith("[]"))
 47119        djd 		{
 47119        djd 					// For byte[] we are going to assume it is input.
 47119        djd 			// For TINYINT output params you gotta use 
 47119        djd 			//  object Integer[] or use a procedure				   
 47119        djd 					if (objectName.equals("byte[]"))
 47119        djd 					{
 47119        djd 						return NOT_OUTPUT_PARAM;
 47119        djd 							
 47119        djd 							//isOutParam[offset] = false;
 47119        djd 							//return java.sql.Types.VARBINARY;
 47119        djd 					}
 47119        djd 					
 47119        djd 					// Known arrays are output parameters
 47119        djd 					// otherwise we pass it's a JAVA_OBJECT
 47119        djd 					if (objectName.equals("java.lang.Byte[]"))
 47119        djd 						return java.sql.Types.TINYINT;
 47119        djd 					
 47119        djd 					if (objectName.equals("byte[][]"))
 47119        djd 						return java.sql.Types.VARBINARY;
 47119        djd 					if (objectName.equals("java.lang.String[]"))
 47119        djd 						return java.sql.Types.VARCHAR; 
 47119        djd 					if (objectName.equals("int[]") || 
 47119        djd 						objectName.equals("java.lang.Integer[]"))
 47119        djd 						return java.sql.Types.INTEGER;
 47119        djd 					else if (objectName.equals("long[]")
 47119        djd 							 || objectName.equals("java.lang.Long[]"))
 47119        djd 						return java.sql.Types.BIGINT;
 47119        djd 					else if (objectName.equals("java.math.BigDecimal[]"))
 47119        djd 						return java.sql.Types.NUMERIC;
 47119        djd 					else if (objectName.equals("boolean[]")  || 
 47119        djd 							 objectName.equals("java.lang.Boolean[]"))
 47119        djd 						return java.sql.Types.BIT;
 47119        djd 					else if (objectName.equals("short[]"))
 47119        djd 						return java.sql.Types.SMALLINT;
 47119        djd 					else if (objectName.equals("float[]") ||
 47119        djd 							 objectName.equals("java.lang.Float[]"))
 47119        djd 						return java.sql.Types.REAL;
 47119        djd 					else if (objectName.equals("double[]") ||
 47119        djd 							 objectName.equals("java.lang.Double[]"))
 47119        djd 						return java.sql.Types.DOUBLE;
 47119        djd 					else if (objectName.equals("java.sql.Date[]"))
 47119        djd 						return java.sql.Types.DATE;
 47119        djd 					else if (objectName.equals("java.sql.Time[]"))
 47119        djd 						return java.sql.Types.TIME;
 47119        djd 					else if (objectName.equals("java.sql.Timestamp[]"))
 47119        djd 						return java.sql.Types.TIMESTAMP;
 47119        djd 		}
 47119        djd 		// Not one of the ones we know. This must be a JAVA_OBJECT
 47119        djd 		return NOT_OUTPUT_PARAM;
 47119        djd 		//isOutParam[offset] = false;				
 47119        djd 		//return java.sql.Types.JAVA_OBJECT;
 47119        djd 
 47119        djd 	}
 47119        djd 	
 47119        djd 	
 47119        djd 	public void registerAllOutParams() throws SQLException
 47119        djd 	{
 47119        djd 		if (isCall && (outputTypes != null))
 47119        djd 			for (int i = 1; i <= outputTypes.length; i ++)
 47119        djd 				registerOutParam(i);
 47119        djd 		
 47119        djd 	}
 47119        djd 	
 47119        djd 	public void registerOutParam(int paramNum) throws SQLException
 47119        djd 	{
 47119        djd 		CallableStatement cs;
 47119        djd 		if (isOutputParam(paramNum))
 47119        djd 		{
 47119        djd 			cs = (CallableStatement) ps;
 47119        djd 			cs.registerOutParameter(paramNum, getOutputParamType(paramNum));
 47119        djd 		}
 47119        djd 	}
 47119        djd 
 47119        djd 	protected boolean hasOutputParams()
 47119        djd 	{
 47119        djd 		return (outputTypes != null);
 47119        djd 	}
 47119        djd 
 47119        djd 	/**
 47119        djd 	 * is  parameter an ouput parameter
 47119        djd 	 * @param paramNum parameter number starting with 1.
 47119        djd 	 * return true if this is an output parameter.
 47119        djd 	 */
 47119        djd 	boolean isOutputParam(int paramNum)
 47119        djd 	{
 47119        djd 		if (outputTypes != null)
 47119        djd 			return (outputTypes[paramNum - 1] != NOT_OUTPUT_PARAM);
 47119        djd 		return false;
 47119        djd 		
 47119        djd 	}
 47119        djd 	/** 
 47119        djd 	 * get type for output parameter. 
 47119        djd 	 *
 47119        djd 	 * @param paramNum - parameter number starting with 1
 47119        djd 	 * @return jdbcType or NOT_OUTPUT_PARAM if this is not an output parameter
 47119        djd 	 */
 47119        djd 	int getOutputParamType(int paramNum)
 47119        djd 	{
 47119        djd 		if (outputTypes != null)
 47119        djd 			return (outputTypes[ paramNum - 1 ]);
 47119        djd 		return NOT_OUTPUT_PARAM;
 47119        djd 	}
 47119        djd 
534985   kmarsden         /** 
534985   kmarsden          * get scale for output parameter. 
534985   kmarsden          *
534985   kmarsden          * @param paramNum - parameter number starting with 1
534985   kmarsden          * @return scale or NOT_OUTPUT_PARAM if this is not an output parameter
534985   kmarsden          */
534985   kmarsden         int getOutputParamScale(int paramNum){
534985   kmarsden             if (outputScale != null)
534985   kmarsden                 return (outputScale[paramNum -1]);
534985   kmarsden             return NOT_OUTPUT_PARAM;
534985   kmarsden         }
534985   kmarsden 
534985   kmarsden         /** 
534985   kmarsden          * get precision  for output parameter. 
534985   kmarsden          *
534985   kmarsden          * @param paramNum - parameter number starting with 1
534985   kmarsden          * @return precision or NOT_OUTPUT_PARAM if this is not an output parameter
534985   kmarsden          */
534985   kmarsden         int getOutputParamPrecision(int paramNum){
534985   kmarsden             if (outputPrecision != null)
534985   kmarsden                 return (outputPrecision[paramNum -1]);
534985   kmarsden             return NOT_OUTPUT_PARAM;
534985   kmarsden         }
534985   kmarsden         
 47119        djd 	private boolean isDynamicPkgid(String pkgid)
 47119        djd 	{
 47119        djd 		char size = pkgid.charAt(3);
 47119        djd 		
 47119        djd 		//  separate attribute used for holdability in 5.1.60
 47119        djd 		// this is just for checking that it is a dynamic package
 47119        djd 		char holdability = pkgid.charAt(4); 			                                    
 47119        djd 		return (pkgid.substring(0,3).equals("SYS") && (size == 'S' ||
 47119        djd 													   size == 'L')
 47119        djd 				&& (holdability == 'H' || holdability == 'N'));
 47119        djd 		
 47119        djd 	}
 47119        djd 
 47119        djd    
 47119        djd 	private  void parsePkgidToFindHoldability()
 47119        djd 	{
 47119        djd 		if (withHoldCursor != -1)
 47119        djd 			return;
380278        djd         
 47119        djd 		//First, check if holdability was passed as a SQL attribute "WITH HOLD" for this prepare. If yes, then withHoldCursor
 47119        djd 		//should not get overwritten by holdability from package name and that is why the check for -1
 47119        djd 		if (isDynamicPkgid(pkgid))
380278        djd 		{       
 47119        djd 			if(pkgid.charAt(4) == 'N')
 47119        djd 				withHoldCursor = JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
 47119        djd 			else  
 47119        djd 				withHoldCursor = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
 47119        djd 		}
 47119        djd 		else 
380278        djd 		{            
 47119        djd 			withHoldCursor = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
 47119        djd 		
 47119        djd 		}
 47119        djd 	}
123827   kmarsden 
123827   kmarsden 
123827   kmarsden 	/**
380278        djd 	 *  prepare a statement using EngineConnection.prepareStatement
380278        djd      *  so that server can run on jdk131 and still pass holdability.  
123827   kmarsden 	 *  @param sqlStmt - SQL statement text
123827   kmarsden 	 *  @param scrollType - scroll type
126257 fuzzylogic 	 *  @param concurType - concurrency type
123827   kmarsden 	 *  @param withHoldCursor - holdability
123827   kmarsden 	 * 
123827   kmarsden 	 *  @throws SQLException
123827   kmarsden 	 *  @return Prepared Statement
123827   kmarsden 	 *  @see java.sql.Connection#prepareStatement
123827   kmarsden 	 */
123827   kmarsden 	private PreparedStatement prepareStatementJDBC3(String sqlStmt, int
123827   kmarsden 													scrollType, int concurType,
123827   kmarsden 													int withHoldCursor) throws SQLException
123827   kmarsden 	{
380278        djd         EngineConnection conn = database.getConnection();
380278        djd         if (withHoldCursor == -1) {
380278        djd             // Holdability not explictly set, let the
380278        djd             // connection provide the default.
380278        djd             return conn.prepareStatement(sqlStmt,
380278        djd                     scrollType, concurType);
380278        djd         }
380278        djd         
380278        djd         // Holdability explictly set. 
380278        djd         return conn.prepareStatement(sqlStmt,
380278        djd                 scrollType, concurType, withHoldCursor);
123827   kmarsden 	}
123827   kmarsden 
123827   kmarsden 	
123827   kmarsden 	/** 
421435    davidvc 	 * Retrieve the ParameterMetaData for the prepared statement. 
495543   kahatlen 	 * @return ParameterMetaData for the prepared statement. 
123827   kmarsden 	 * Note: there is no separate BrokeredParameterSetMetaData.
123827   kmarsden 	 */
495543   kahatlen 	protected ParameterMetaData getParameterMetaData() throws SQLException
123827   kmarsden 	{
123827   kmarsden 		if (stmtPmeta != null)
123827   kmarsden 			return stmtPmeta;
123827   kmarsden 
495543   kahatlen 		stmtPmeta = ps.getParameterMetaData();
421435    davidvc         
421435    davidvc         return stmtPmeta;
123827   kmarsden 	}
123827   kmarsden 	
123827   kmarsden 	/**
123827   kmarsden 	 * get more results using reflection.
123827   kmarsden 	 * @param current - flag to pass to Statement.getMoreResults(current)
123827   kmarsden 	 * @return true if there are more results.
123827   kmarsden 	 * @throws SQLException
126257 fuzzylogic 	 * @see java.sql.Statement#getMoreResults
123827   kmarsden 	 *
123827   kmarsden 	 */
391691        djd 	private boolean getMoreResults(int current) throws SQLException
391691        djd 	{       
495543   kahatlen         return getPreparedStatement().getMoreResults(current);
123827   kmarsden 	}
123827   kmarsden 
123827   kmarsden 	/**
123827   kmarsden 	 * Use reflection to retrieve SQL Text for EmbedPreparedStatement  
123827   kmarsden 	 * or BrokeredPreparedStatement.
123827   kmarsden 	 * @return SQL text
123827   kmarsden 	 */
123827   kmarsden 	private String getSQLText() 
123827   kmarsden 	{
123827   kmarsden 	   String retVal = null;
123827   kmarsden 		Class[] emptyPARAM = {};
123827   kmarsden 		Object[] args = null;
123827   kmarsden 		try {
123827   kmarsden 			Method sh = getPreparedStatement().getClass().getMethod("getSQLText",emptyPARAM);
123827   kmarsden 			retVal = (String) sh.invoke(getPreparedStatement(),args);
123827   kmarsden 		}
123827   kmarsden 		catch (Exception e)
123827   kmarsden 		{
123827   kmarsden 			//  do nothing we will just return a null string
123827   kmarsden 		}
123827   kmarsden 		return retVal;
123827   kmarsden 
123827   kmarsden 	}
123827   kmarsden 
123827   kmarsden 	/** helper method to handle exceptions generated by methods invoked 
123827   kmarsden 	 * through  reflection.
123827   kmarsden 	 * @param e - exception thrown
123827   kmarsden 	 * @throws SQLException - actual exception that occurred
123827   kmarsden 	 */
123827   kmarsden 	private void handleReflectionException(Exception e) throws SQLException
123827   kmarsden 	{
123827   kmarsden 		if  (e instanceof InvocationTargetException) 
123827   kmarsden 		{
123827   kmarsden 			Throwable t = ((InvocationTargetException) e).getTargetException();
123827   kmarsden 			
123827   kmarsden 			if (t  instanceof SQLException)
123827   kmarsden 			{
123827   kmarsden 				throw (SQLException) t;
123827   kmarsden 			}
123827   kmarsden 			else
124273   kmarsden 			{
156229   kmarsden 				t.printStackTrace();
123827   kmarsden 				throw Util.javaException(t);
124273   kmarsden 			}
123827   kmarsden 		}
123827   kmarsden 		else
123827   kmarsden 			// invoke can throw IllegalAccessException or 
123827   kmarsden 			// IllegalArgumentException, but these should not 
123827   kmarsden 			// occur from this code. Just in case we will throw it
123827   kmarsden 			throw Util.javaException(e);
123827   kmarsden 		
123827   kmarsden 	}
189752   kmarsden 	
189752   kmarsden 	/**
377367      bernt 	 * Method to decide whether the ResultSet should be closed
377367      bernt 	 * implicitly based on the QRYCLSIMP value sent from the
377367      bernt 	 * client. Only forward-only result sets should be implicitly
377367      bernt 	 * closed. Some clients do not expect result sets to be closed
377367      bernt 	 * implicitly if the protocol is LMTBLKPRC.
377367      bernt 	 *
377367      bernt 	 * @param lmtblkprcOK <code>true</code> if the client expects
377367      bernt 	 * QRYCLSIMP to be respected for the LMTBLKPRC protocol
189752   kmarsden 	 * @return implicit close boolean
377367      bernt 	 * @exception SQLException
189752   kmarsden 	 */
377367      bernt 	boolean isRSCloseImplicit(boolean lmtblkprcOK) throws SQLException {
377367      bernt 		return
377367      bernt 			(currentDrdaRs.qryclsimp == CodePoint.QRYCLSIMP_YES) &&
377367      bernt 			!isScrollable() &&
377367      bernt 			(lmtblkprcOK ||
377367      bernt 			 (currentDrdaRs.getQryprctyp() != CodePoint.LMTBLKPRC));
189752   kmarsden 	}
 47119        djd }
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
374029      bernt 
